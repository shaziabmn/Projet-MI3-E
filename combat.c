#include <stdio.h>              // Entr√©es/sorties standard
#include <stdlib.h>             // Fonctions utilitaires (malloc, rand, etc.)
#include <string.h>             // Manipulation de cha√Ænes
#include <time.h>               // Pour initialiser le g√©n√©rateur al√©atoire

#include "combat.h"             // D√©finitions li√©es au combat
#include "interface.h"          // Fonctions d'affichage

// Charge les combattants depuis un fichier texte
int charger_combattants(const char *nomFichier, Combattant liste[]) {
    FILE *f = fopen(nomFichier, "r");              // Ouvre le fichier en mode lecture
    if (!f) {                                      // Si erreur √† l‚Äôouverture
        perror("Erreur ouverture fichier");
        return 0;
    }

    char ligne[1000];                              // Buffer pour lire chaque ligne
    int nb_combattants = 0;                        // Compteur de combattants charg√©s

    // Lire et extraire les donn√©es format√©es depuis la ligne (combattants.txt)
    while (fgets(ligne, sizeof(ligne), f) && nb_combattants < MAX_COMBATTANTS) {
        Combattant *c = &liste[nb_combattants];    // R√©cup√®re un pointeur vers le prochain combattant √† remplir

        // Extraction des donn√©es du fichier texte
        sscanf(ligne, "%[^;];%d;%d;%d;%d;%d;%[^;];%d;%[^;];%d;%d",
            c->nom, &c->pv_max, &c->attaque, &c->defense,
            &c->agilite, &c->vitesse,
            c->technique.nom, &c->technique.valeur, c->technique.description,
            &c->technique.tours_actifs, &c->technique.tours_rechargement);

        c->pv_courants = c->pv_max;                // Initialise les PV courants au maximum
        nb_combattants++;                          // Passe au combattant suivant
    }

    fclose(f);                                     // Ferme le fichier
    return nb_combattants;                         // Retourne le nombre total de combattants charg√©s
}

// V√©rifie si tous les combattants d'une √©quipe sont KO
int equipe_KO(Equipe *e) {
    for (int i = 0; i < NB_COMBATTANTS; i++) {
        if (e->combattant[i].pv_courants > 0) {
            return 0;                              // Au moins un vivant
        }
    }
    return 1;                                      // Tous KO
}

// G√®re la recharge de la technique sp√©ciale (si applicable)
void gerer_effets_tour(Combattant *c) {
    if (c->technique.tours_rechargement > 0) {             // Si rechargement en cours
        c->technique.tours_rechargement--;                 // Diminue le nombre de tours restants avant utilisation
        if (c->technique.tours_rechargement == 0) {        // Si technique pr√™te
            printf(BOLD_GREEN"\nLa technique sp√©ciale %s de %s est pr√™te √† √™tre utilis√©e ! üß™\n\n"RESET,
                   c->technique.nom, c->nom);
        }
    }
}

// Effectue une attaque classique entre 2 combattants
void attaquer(Combattant *attaquant, Combattant *defenseur) {
    if (attaquant->pv_courants <= 0) {                     // Si attaquant KO
        printf(RED"%s est d√©j√† KO ‚ò†Ô∏è ! Vous ne pouvez pas attaquer. \n"RESET, attaquant->nom);
        return;
    }

    int degats = attaquant->attaque - defenseur->defense;  // Calcule les d√©g√¢ts
    if (degats <= 0) degats = 1;                           // Minimum 1 d√©g√¢t

    defenseur->pv_courants -= degats;                      // Applique les d√©g√¢ts
    if (defenseur->pv_courants < 0)
        defenseur->pv_courants = 0;                        // Ne descend pas sous 0

    // Affiche le r√©sultat
    printf(BOLD_CYAN"\n\n%s attaque %s pour %d d√©g√¢ts ! %s a maintenant %d PV ! üå™Ô∏è\n\n"RESET,
           attaquant->nom, defenseur->nom, degats, defenseur->nom, defenseur->pv_courants);
}

// Utilise la technique sp√©ciale du combattant
void utiliser_technique(Combattant *utilisateur, Combattant *cible) {
    Technique *t = &utilisateur->technique;                // R√©cup√®re un pointeur vers la technique sp√©ciale du combattant utilisateur

    if (t->tours_rechargement > 0) {                       // Si rechargement en cours, message d'erreur et quitte la fonction
        printf(BOLD_GREEN"\n\nLa technique sp√©ciale %s est encore en recharge. ‚è≥\n"RESET, t->nom);
        printf(BOLD_GREEN"Il vous reste %d tour(s) avant de pouvoir l‚Äôutiliser. ‚è±Ô∏è\n\n"RESET, t->tours_rechargement);
        return;
    }
    
    // Affiche que la technique est utilis√©e
    printf(BOLD_WHITE"\n\n%s utilise %s ! üåü\n\n"RESET, utilisateur->nom, t->nom); 

    // Diff√©rents effets selon le nom de la technique
// Cas : la technique est "Soin"
if (strcmp(t->nom, "Soin") == 0) {
    int pv_avant = utilisateur->pv_courants; // On sauvegarde les PV actuels du combattant pour calculer combien il r√©cup√®re
    utilisateur->pv_courants += t->valeur;   // On ajoute √† ses PV la valeur de soin indiqu√©e dans la technique

    if (utilisateur->pv_courants > utilisateur->pv_max) // Si apr√®s soin, les PV d√©passent le max autoris√©
        utilisateur->pv_courants = utilisateur->pv_max; // On limite les PV au maximum (on ne peut pas d√©passer)

    // On affiche un message montrant combien de PV ont √©t√© soign√©s et le total de PV actuels
    printf(BOLD_CYAN"%s r√©cup√®re %d PV ! %s a maintenant %d PV ! üíé\n"RESET,
           utilisateur->nom, utilisateur->pv_courants - pv_avant, utilisateur->nom, utilisateur->pv_courants);

} 
// Cas : technique offensive simple ("Frappe" ou "Esquive")
else if (strcmp(t->nom, "Frappe") == 0 || strcmp(t->nom, "Esquive") == 0) {
    cible->pv_courants -= t->valeur; // On retire √† la cible les PV correspondant √† la puissance de la technique
    if (cible->pv_courants < 0) cible->pv_courants = 0; // On emp√™che les PV de devenir n√©gatifs

    // On affiche un message de d√©g√¢ts inflig√©s √† l‚Äôadversaire
    printf(BOLD_CYAN"%s inflige %d d√©g√¢ts √† %s ! %s a maintenant %d PV ! üéØ\n"RESET,
           utilisateur->nom, t->valeur, cible->nom, cible->nom, cible->pv_courants);

} 
// Cas : technique d√©fensive ("Bouclier")
else if (strcmp(t->nom, "Bouclier") == 0) {
    int pv_avant = utilisateur->pv_courants; // On sauvegarde les PV avant d‚Äôajouter la protection
    utilisateur->pv_courants += t->valeur;   // On ajoute les PV fournis par le bouclier

    if (utilisateur->pv_courants > utilisateur->pv_max) // Si les PV d√©passent le maximum
        utilisateur->pv_courants = utilisateur->pv_max; // On les limite au maximum autoris√©

    // On affiche un message indiquant la r√©cup√©ration de PV par le bouclier
    printf(BOLD_CYAN"%s r√©cup√®re %d PV ! %s a maintenant %d PV ! üõ°Ô∏è\n"RESET,
           utilisateur->nom, utilisateur->pv_courants - pv_avant, utilisateur->nom, utilisateur->pv_courants);

} 
// Cas : technique magique puissante ("Sortil√®ge")
else if (strcmp(t->nom, "Sortil√®ge") == 0) {
    utilisateur->pv_courants *= 2; // Double les PV actuels du combattant

    if (utilisateur->pv_courants > utilisateur->pv_max) // Mais sans d√©passer les PV max
        utilisateur->pv_courants = utilisateur->pv_max;

    // Affiche que le sortil√®ge a doubl√© les PV
    printf(BOLD_CYAN"%s double ses PV ! %s a maintenant %d PV ! üîÆ\n"RESET,
        utilisateur->nom, utilisateur->nom, utilisateur->pv_courants);
} 

// Cas : attaque strat√©gique ("Rapidit√©")
else if (strcmp(t->nom, "Rapidit√©") == 0) {
    cible->pv_courants /= 2; // R√©duit les PV de la cible de moiti√©

    if (cible->pv_courants < 0) cible->pv_courants = 0; // Par s√©curit√©, on √©vite les PV n√©gatifs

    // Message indiquant que les PV de l‚Äôennemi sont divis√©s
    printf(BOLD_CYAN"%s divise les PV de %s ! %s a maintenant %d PV ! üå©Ô∏è\n"RESET,
           utilisateur->nom, cible->nom, cible->nom, cible->pv_courants);
}
}


// Fonction appel√©e quand c'est au tour d'un joueur (√©quipe active) de jouer
// Le joueur peut attaquer ou utiliser une technique sp√©ciale sur l'√©quipe adverse
void tour_joueur(Equipe *active, Equipe *adverse, int index) {
    // Si l‚Äôindex du combattant actif d√©passe la taille de l‚Äô√©quipe, on sort imm√©diatement (s√©curit√©)
    if (index >= NB_COMBATTANTS) return;

    // On r√©cup√®re un pointeur vers le combattant actif de l‚Äô√©quipe
    Combattant *c = &active->combattant[index];

    // Si ce combattant est KO (0 PV ou moins) OU si tous les ennemis sont d√©j√† KO, on ne fait rien
    if (c->pv_courants <= 0 || equipe_KO(adverse)) return;

    // Affichage du tour de l'√©quipe active avec un effet visuel
    printf(BOLD_MAGENTA"\n\n\n\n\n--- üïπÔ∏è  √Ä VOUS DE JOUER, √âQUIPE %s ! üïπÔ∏è  ---\n\n\n"RESET, active->nom);

    // Affiche toutes les cibles ennemies, avec leurs PV ou "KO" si elles sont √©limin√©es
    printf(BOLD_YELLOW"Cibles disponibles üìù :\n\n"RESET);
    int cibles_valides = 0; // Compte le nombre de cibles valides

    for (int j = 0; j < NB_COMBATTANTS; j++) {
        // Si le combattant adverse est encore vivant, on affiche ses PV
        if (adverse->combattant[j].pv_courants > 0) {
            printf("%d. %s (%d PV) \n", j + 1, adverse->combattant[j].nom, adverse->combattant[j].pv_courants);
            cibles_valides++; // On note qu‚Äôon a une cible possible
        } else {
            // Sinon, on indique que le combattant est KO
            printf("%d. %s (KO) ‚ò†Ô∏è\n", j + 1, adverse->combattant[j].nom);
        }
    }

    // Si aucune cible n'est disponible, on termine le tour
    if (cibles_valides == 0) return;

    // Boucle pour s√©lectionner une cible valide
    int cible_index, cible_valide = 0;
    while (!cible_valide) {
        printf(BOLD_YELLOW"\n\nChoisissez une cible üèπ :\n\n> "RESET);

        // Lecture de l‚Äôentr√©e utilisateur
        if (scanf("%d", &cible_index) != 1) {
            // Si l'entr√©e n‚Äôest pas un nombre, on vide le buffer et affiche un message d‚Äôerreur
            while (getchar() != '\n');
            printf(RED"‚ùå Choix invalide.\n"RESET);
            continue;
        }

        cible_index--; // On ajuste car l'utilisateur entre 1, 2 ou 3 (mais on travaille en 0, 1, 2)

        // On v√©rifie que l‚Äôindex est valide et que le combattant n‚Äôest pas KO
        if (cible_index >= 0 && cible_index < NB_COMBATTANTS &&
            adverse->combattant[cible_index].pv_courants > 0) {
            cible_valide = 1; // Cible valide : on sortira de la boucle
        } else {
            printf(RED"‚ùå Cible invalide ou d√©j√† KO.\n"RESET);
        }
    }

    // Boucle pour s√©lectionner l‚Äôaction √† effectuer (1 = attaquer, 2 = technique)
    int choix = 0;
    while (choix != 1 && choix != 2) {
        // On affiche le menu d'action pour le joueur
        printf(BOLD_BLUE"\n\n\n%s veut agir :\n\n"RESET, c->nom);
        printf("1. Attaquer üëä\n2. Utiliser la technique sp√©ciale üí´\n");
        printf(BOLD_BLUE"\n> "RESET);

        // Lecture du choix
        if (scanf("%d", &choix) != 1) {
            while (getchar() != '\n'); // Vide le buffer si l'entr√©e est invalide
            printf(RED"‚ùå Choix invalide. Veuillez entrer '1' pour attaquer ou '2' pour utiliser la technique sp√©cial.\n\n"RESET);
            choix = 0; // On r√©initialise pour que la boucle recommence
            continue;
        } 
        else if (choix != 1 && choix != 2) {
            printf(RED"‚ùå Choix invalide. Veuillez entrer '1' pour attaquer ou '2' pour utiliser la technique sp√©cial.\n\n"RESET);
        }

        // Si le joueur a choisi la technique, mais qu‚Äôelle est en recharge, on affiche un message d‚Äôerreur
        if (choix == 2 && c->technique.tours_rechargement > 0) {
            
            printf(BOLD_GREEN"\nLa technique sp√©ciale %s est encore en recharge. ‚è±Ô∏è\n"RESET, c->technique.nom);
            printf(BOLD_GREEN"Il vous reste %d tour(s) avant de pouvoir l‚Äôutiliser. ‚è≥\n"RESET, c->technique.tours_rechargement);
            choix = 0; // On demande √† l'utilisateur de choisir √† nouveau
            
        }
    }

    // Une fois que l‚Äôaction est valid√©e :
    // Si choix = 1, on appelle la fonction d‚Äôattaque normale
    if (choix == 1)
        attaquer(c, &adverse->combattant[cible_index]);
    else
        // Sinon, on utilise la technique sp√©ciale
        utiliser_technique(c, &adverse->combattant[cible_index]);

    // √Ä la fin du tour, si aucune √©quipe n‚Äôest compl√®tement KO,
    // on g√®re les effets qui doivent s‚Äôappliquer en fin de tour (ex: recharges, bonus temporaires, etc.)
    if (!equipe_KO(active) && !equipe_KO(adverse)) {
        gerer_effets_tour(c);
    }
}

// Lance le combat entre deux √©quipes
void lancer_combat(Equipe *e1, Equipe *e2) {
    // Message d‚Äôintroduction
    printf(YELLOW "\n\n\n\n\n                  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"RESET);
    printf(BOLD_WHITE"                             ‚öîÔ∏è  LE COMBAT COMMENCE ! ‚öîÔ∏è         "RESET);
    printf(YELLOW "\n                  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"RESET);
    printf("\n\n");

    srand(time(NULL));                          // Initialise le g√©n√©rateur al√©atoire

    int vmax1 = 0, vmax2 = 0;

    // Calcule vitesse max de chaque √©quipe
    for (int i = 0; i < NB_COMBATTANTS; i++)
        if (e1->combattant[i].vitesse > vmax1) vmax1 = e1->combattant[i].vitesse;
    for (int i = 0; i < NB_COMBATTANTS; i++)
        if (e2->combattant[i].vitesse > vmax2) vmax2 = e2->combattant[i].vitesse;

    int equipe_commence;

    // D√©termine l'√©quipe qui commence
    if (vmax1 > vmax2) {
        equipe_commence = 1;
        printf(YELLOW "\n%s poss√®de le combattant le plus rapide et d√©butera ce combat ! üëÄ\n" RESET, e1->nom);
    } else if (vmax2 > vmax1) {
        equipe_commence = 2;
        printf(BOLD_YELLOW "\n%s poss√®de le combattant le plus rapide et d√©butera ce combat ! üëÄ\n" RESET, e2->nom);
    } else {
        equipe_commence = (rand() % 2) + 1;
        printf(BOLD_YELLOW "Les deux √©quipes ont un combattant aussi rapide ! ü•∑\n" RESET);
        printf(BOLD_YELLOW "Tirage au sort...ü•Å %s COMMENCERA CE COMBAT ! üöÄ\n" RESET, equipe_commence == 1 ? e1->nom : e2->nom);
    }

    // Boucle principale de combat entre les deux √©quipes
for (int tour = 1; tour < 999; tour++) {
    // Si l‚Äô√©quipe 1 est compl√®tement KO, alors l‚Äô√©quipe 2 gagne
    if (equipe_KO(e1)) {
        printf(BOLD_GREEN"\nVICTOIRE DE %s ! üèÜ\n"RESET, e2->nom);
        return; // Fin du combat
    }

    // Si l‚Äô√©quipe 2 est compl√®tement KO, alors l‚Äô√©quipe 1 gagne
    if (equipe_KO(e2)) {
        printf(BOLD_GREEN"\nVICTOIRE DE %s ! üèÜ\n"RESET, e1->nom);
        return; // Fin du combat
    }

    // Affichage stylis√© du num√©ro de tour
    printf(MAGENTA "\n\n\n\n\n                  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"RESET);
    printf(BOLD_WHITE"                             üö® TOUR %d : PR√âPAREZ VOUS ! üö®         "RESET, tour);
    printf(MAGENTA "\n                  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"RESET);

    // Chaque tour est compos√© de 3 sous-tours (un pour chaque combattant)
    for (int i = 0; i < 3; i++) {
        // On commence par faire jouer une √©quipe, selon l‚Äôordre d√©termin√© au d√©but
        Equipe *active = (equipe_commence == 1) ? e1 : e2;    // L‚Äô√©quipe qui commence
        Equipe *adverse = (equipe_commence == 1) ? e2 : e1;   // L‚Äô√©quipe adverse

        // Si l‚Äô√©quipe active est encore debout, son combattant i joue
        if (!equipe_KO(active)) tour_joueur(active, adverse, i);

        // On v√©rifie apr√®s chaque action si l‚Äô√©quipe adverse est √©limin√©e
        if (equipe_KO(adverse)) {
            printf(BOLD_GREEN"\nVICTOIRE DE %s ! üèÜ\n"RESET, active->nom);
            return; // Fin du combat
        }

        // Puis c‚Äôest au tour de l‚Äôautre √©quipe
        active = (equipe_commence == 1) ? e2 : e1;     // Inversion des r√¥les
        adverse = (equipe_commence == 1) ? e1 : e2;

        // M√™me chose : si cette √©quipe est encore en vie, son combattant i joue
        if (!equipe_KO(active)) tour_joueur(active, adverse, i);

        // V√©rifie de nouveau si l‚Äô√©quipe adverse est KO apr√®s l‚Äôaction
        if (equipe_KO(adverse)) {
            printf(BOLD_GREEN"\nVICTOIRE DE %s ! üèÜ\n"RESET, active->nom);
            return; // Fin du combat
            }
        }
    }
}
